from typing import Tuple
from dijkstra import Dijkstra
from edgeweighteddigraph import EdgeWeightedDigraph
from directededge import DirectedEdge

def get_graph_and_source_from_txt(path : str) -> Tuple[EdgeWeightedDigraph, int]:
    dijkstra_source_vertex = None
    n_vertices = None
    graph = None
    with open(path, 'r') as file:
        for line in file:
            if not dijkstra_source_vertex:
                dijkstra_source_vertex = int(line.strip().replace('node_', ''))
                continue
            
            entries = line.strip().split(',')

            if not graph:
                n_vertices = len(entries)
                graph = EdgeWeightedDigraph(n_vertices)
        
            source = int(entries[0].replace('node_', ''))
            for target, weight in enumerate(entries[1:]):
                try:
                    weight = float(weight)
                    if weight > 0:
                        graph.add_edge(DirectedEdge(source, target + 1, weight))
                except ValueError:
                    # Ignore edges with non numeric weights
                    pass

    return graph, dijkstra_source_vertex

def save_shortest_paths_as_txt(dijkstra : Dijkstra, output_file):
    vertices_ordered_by_distance = [i[0] for i in sorted(enumerate(dijkstra.get_distances()), key=lambda x: x[1])]
    output = [f'SHORTEST PATH TO node_{source}: node_{source} <- node_{source} (Distance: 0.00)']
    for vertex in vertices_ordered_by_distance:
        if vertex == source:
            continue
        else:
            path = dijkstra.get_path_to(vertex)
            if not path:
                continue
            else:
                reversed_path = [f'node_{path[0].target}']
                for edge in path:
                    reversed_path.append(f'node_{edge.source}')
                str_path = ' <- '.join(reversed_path)
                output.append(f'SHORTEST PATH TO node_{vertex}: {str_path} (Distance: {dijkstra.get_distance_to(vertex):.2f})')

    with open(output_file, 'w') as f:
        f.write('\n'.join(output))

if __name__ == '__main__':
    import time
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('input')
    parser.add_argument('output')
    args = parser.parse_args()
    
    graph, source = get_graph_and_source_from_txt(args.input)

    start = time.time()
    dijkstra = Dijkstra(graph, source)
    print(f'Elapsed time: {time.time() - start}')

    save_shortest_paths_as_txt(dijkstra, args.output)